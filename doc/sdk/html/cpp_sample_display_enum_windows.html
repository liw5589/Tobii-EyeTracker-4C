<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tobii Interaction Library SDK: C++ Display Enumeration Sample (Windows only) Complete Code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
<link href="code.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.15 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">C++ Display Enumeration Sample (Windows only) Complete Code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>[<a href="../../sdk/html/index.html">Back to the SDK Overview</a>]</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">COPYRIGHT 2018-2020  - PROPERTY OF TOBII AB</span></div><div class="line"><span class="comment">-------------------------------------</span></div><div class="line"><span class="comment">2018-2020 TOBII AB - KARLSROVAGEN 2D, DANDERYD 182 53, SWEDEN - All Rights Reserved.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">NOTICE:  All information contained herein is, and remains, the property of Tobii AB and its suppliers, if any.</span></div><div class="line"><span class="comment">The intellectual and technical concepts contained herein are proprietary to Tobii AB and its suppliers and may be</span></div><div class="line"><span class="comment">covered by U.S.and Foreign Patents, patent applications, and are protected by trade secret or copyright law.</span></div><div class="line"><span class="comment">Dissemination of this information or reproduction of this material is strictly forbidden unless prior written</span></div><div class="line"><span class="comment">permission is obtained from Tobii AB.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;interaction_lib/InteractionLib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;interaction_lib/misc/InteractionLibPtr.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;windows.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div><div class="line"><span class="preprocessor">#define DISPLAY_ENUMERATION_HELPER_IMPLEMENTATION</span></div><div class="line"><span class="preprocessor">#include &lt;DisplayEnumerationHelper.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// This a simple C++ wrapper for a Win32 HWND window representation.</span></div><div class="line"><span class="comment">// Note that there is no real error handling, since its main purpose</span></div><div class="line"><span class="comment">// is to support the Interaction Library SDK C++ sample that shows how</span></div><div class="line"><span class="comment">// to use the display enumeration helper functions.</span></div><div class="line"><span class="keyword">class </span>Window final</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Window creation might trigger all of the OnPaint, OnMove and OnSize events.</span></div><div class="line">    <span class="keywordtype">void</span> Create();</div><div class="line"></div><div class="line">    <span class="comment">// When a window is repainted, the OnPaint event is triggered.</span></div><div class="line">    <span class="keywordtype">void</span> Repaint();</div><div class="line"></div><div class="line">    <span class="comment">// The int&amp; out parameter tells the window what Win32 system color index it should</span></div><div class="line">    <span class="comment">// use when painting its client area, for instance COLOR_WINDOW or COLOR_HIGHLIGHT.</span></div><div class="line">    std::function&lt;void(<span class="keywordtype">int</span>&amp;)&gt; OnPaint;</div><div class="line"></div><div class="line">    <span class="comment">// The float parameters are the new x and y positions of the window client area</span></div><div class="line">    <span class="comment">// origo, relative to the primary screen origo.</span></div><div class="line">    std::function&lt;void(<span class="keywordtype">float</span>, <span class="keywordtype">float</span>)&gt; OnMove;</div><div class="line"></div><div class="line">    <span class="comment">// The float parameters are the new width and height of the window client area.</span></div><div class="line">    std::function&lt;void(<span class="keywordtype">float</span>, <span class="keywordtype">float</span>)&gt; OnSize;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// The window procedure handles messages that are needed to invoke the public events.</span></div><div class="line">    <span class="keyword">static</span> LRESULT CALLBACK WindowProcedure(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);</div><div class="line"></div><div class="line">    HWND m_hwnd{};</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Window::Create()</div><div class="line">{</div><div class="line">    WNDCLASSA wc{};</div><div class="line">    wc.hInstance = GetModuleHandle(<span class="keyword">nullptr</span>);</div><div class="line">    wc.lpfnWndProc = WindowProcedure;</div><div class="line">    wc.lpszClassName = <span class="stringliteral">&quot;TobiiInteractorWindow&quot;</span>;</div><div class="line"></div><div class="line">    RegisterClassA(&amp;wc);</div><div class="line"></div><div class="line">    CreateWindowA(wc.lpszClassName, <span class="stringliteral">&quot;Interactor Window&quot;</span>,</div><div class="line">                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,</div><div class="line">                  CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</div><div class="line">                  NULL, NULL, GetModuleHandle(<span class="keyword">nullptr</span>), <span class="keyword">this</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Window::Repaint()</div><div class="line">{</div><div class="line">    InvalidateRect(m_hwnd, NULL, FALSE);</div><div class="line">}</div><div class="line"></div><div class="line">LRESULT Window::WindowProcedure(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> Window* window{};</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (msg)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> WM_CREATE:</div><div class="line">        {</div><div class="line">            CREATESTRUCTA* cs{reinterpret_cast&lt;CREATESTRUCTA*&gt;(lp)};</div><div class="line">            window = static_cast&lt;Window*&gt;(cs-&gt;lpCreateParams);</div><div class="line">            window-&gt;m_hwnd = hwnd;</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> 0;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">case</span> WM_MOVE:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (window-&gt;OnMove)</div><div class="line">            {</div><div class="line">                POINT offset{};</div><div class="line">                ClientToScreen(hwnd, &amp;offset);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> x = static_cast&lt;float&gt;(offset.x);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> y = static_cast&lt;float&gt;(offset.y);</div><div class="line">                window-&gt;OnMove(x, y);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> 0;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">case</span> WM_SIZE:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (window-&gt;OnSize)</div><div class="line">            {</div><div class="line">                RECT rect{};</div><div class="line">                GetClientRect(hwnd, &amp;rect);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> width = static_cast&lt;float&gt;(rect.right - rect.left);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> height = static_cast&lt;float&gt;(rect.bottom - rect.top);</div><div class="line">                window-&gt;OnSize(width, height);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> 0;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">case</span> WM_ERASEBKGND:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">return</span> 1;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">case</span> WM_PAINT:</div><div class="line">        {</div><div class="line">            PAINTSTRUCT ps{};</div><div class="line">            HDC hdc{BeginPaint(hwnd, &amp;ps)};</div><div class="line">            <span class="keywordtype">int</span> sysColorIndex = COLOR_WINDOW;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (window-&gt;OnPaint)</div><div class="line">                window-&gt;OnPaint(sysColorIndex);</div><div class="line"></div><div class="line">            FillRect(hdc, &amp;ps.rcPaint, GetSysColorBrush(sysColorIndex));</div><div class="line">            EndPaint(hwnd, &amp;ps);</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> 0;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">case</span> WM_DESTROY:</div><div class="line">        {</div><div class="line">            window-&gt;m_hwnd = <span class="keyword">nullptr</span>;</div><div class="line">            window = <span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line">            PostQuitMessage(0);</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> 0;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">return</span> DefWindowProc(hwnd, msg, wp, lp);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// This one way to implement a Win32 &quot;message pump&quot; that not only</span></div><div class="line"><span class="comment">// handles window input from the user and the system, but also</span></div><div class="line"><span class="comment">// integrates with an external &quot;event source&quot; - an eye tracker.</span></div><div class="line"><span class="keywordtype">bool</span> ProcessMessages()</div><div class="line">{</div><div class="line">    MSG msg{};</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (PeekMessageA(&amp;msg, NULL, 0, 0, PM_REMOVE))</div><div class="line">    {</div><div class="line">        <span class="comment">// When the window is destroyed, it posts a quit message,</span></div><div class="line">        <span class="comment">// which is picked up here as &quot;stop processing messages&quot;.</span></div><div class="line">        <span class="keywordflow">if</span> (msg.message == WM_QUIT)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        TranslateMessage(&amp;msg);</div><div class="line">        DispatchMessageA(&amp;msg);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, <span class="keywordtype">int</span>)</div><div class="line">{</div><div class="line">    <span class="comment">// create the interaction library</span></div><div class="line">    IL::UniqueInteractionLibPtr intlib{IL::CreateInteractionLib(IL::FieldOfUse::Interactive)};</div><div class="line"></div><div class="line">    <span class="comment">// This is just a helper function to make the underlying C function</span></div><div class="line">    <span class="comment">// easier to use in a C++ context.</span></div><div class="line">    <span class="keyword">auto</span> GetMonitorDisplayAreas = []</div><div class="line">    {</div><div class="line">        std::vector&lt;MonitorDisplayAreaA&gt; areas{5}; <span class="comment">// unusual to have more than 5 monitors...</span></div><div class="line">        <span class="keywordtype">int</span> found{};</div><div class="line">        </div><div class="line">        <span class="comment">// This is the raw C display area enumeration helper function.</span></div><div class="line">        <span class="comment">// It will enumerate all displays on the windows machine, including their virtual </span></div><div class="line">        <span class="comment">// screen bounds and display IDs, and put the results into the supplied array of structs.</span></div><div class="line">        <span class="comment">// The display IDs have the same formatting as are used on Tobii eyetrackers to </span></div><div class="line">        <span class="comment">// identify which display they are attached to. </span></div><div class="line">        EnumerateDisplayAreasA(areas.data(), &amp;found, static_cast&lt;int&gt;(areas.size()));</div><div class="line">        areas.resize(found);</div><div class="line">        <span class="keywordflow">return</span> areas;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// When all displays are identified, pass their information to the Interaction Library.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; area : GetMonitorDisplayAreas())</div><div class="line">    {</div><div class="line">        <span class="comment">// For each display we tell the Interaction Library</span></div><div class="line">        <span class="comment">// 1) the coordinate scaling we want to use by giving the size as we see it</span></div><div class="line">        <span class="comment">// 2) the size and origin in virtual screen coordinates, and </span></div><div class="line">        <span class="comment">// 3) the ID of the display.</span></div><div class="line">        <span class="comment">// </span></div><div class="line">        <span class="comment">// Interaction Library will use this information to map connected devices to display areas,</span></div><div class="line">        <span class="comment">// to transform all data streams when outputting them and to properly transform all added </span></div><div class="line">        <span class="comment">// interactors to its internal, global coordinate space when performing gaze focus calculations.</span></div><div class="line">        <span class="comment">// </span></div><div class="line">        <span class="comment">// Here we are using the native scaling (so first to parameters are the same as the virtual </span></div><div class="line">        <span class="comment">// screen size) but we could have  used any scaling we like, eg (1.0, 1.0) for relative </span></div><div class="line">        <span class="comment">// coordinates.</span></div><div class="line">        intlib-&gt;CoordinateTransformAddOrUpdateDisplayArea(</div><div class="line">            area.wVirtual, area.hVirtual,</div><div class="line">            area.wVirtual, area.hVirtual,</div><div class="line">            area.xVirtual, area.yVirtual,</div><div class="line">            area.monitorId);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// All events must have handlers before the physical window is created, so that</span></div><div class="line">    <span class="comment">// any resizing, moving and painting done by the system during window creation</span></div><div class="line">    <span class="comment">// is picked up by our application logic.</span></div><div class="line">    Window window;</div><div class="line"></div><div class="line">    <span class="comment">// By telling the Interaction Library to offset the coordinate system origin</span></div><div class="line">    <span class="comment">// so that it matches the location of the window client area, we can add and</span></div><div class="line">    <span class="comment">// update interactors using window-local coordinates.</span></div><div class="line">    <span class="comment">// The origin offset has to be in the virtual coordinate space we used when </span></div><div class="line">    <span class="comment">// adding the display areas above.</span></div><div class="line">    window.OnMove = [&amp;] (<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y)</div><div class="line">    {</div><div class="line">        intlib-&gt;CoordinateTransformSetOriginOffset(x, y);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// In this sample we want the entire window client area to be an interactor</span></div><div class="line">    <span class="comment">// that changes color when it gets and loses gaze focus.</span></div><div class="line">    window.OnSize = [&amp;] (<span class="keywordtype">float</span> width, <span class="keywordtype">float</span> height)</div><div class="line">    {</div><div class="line">        <span class="comment">// setup the window client area as an interactor</span></div><div class="line">        intlib-&gt;BeginInteractorUpdates();</div><div class="line">        intlib-&gt;AddOrUpdateInteractor(0, {0.0f, 0.0f, width, height}, 0.0f);</div><div class="line">        intlib-&gt;CommitInteractorUpdates();</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>GazeFocusEventContext final</div><div class="line">    {</div><div class="line">        <span class="keywordtype">bool</span> focused;</div><div class="line">        Window&amp; window;</div><div class="line">    } gazeFocusEventContext{<span class="keyword">false</span>, window};</div><div class="line"></div><div class="line">    <span class="comment">// Subscribe to gaze focus events. When the window client area (which is an</span></div><div class="line">    <span class="comment">// interactor) gets or loses gaze focus, the &quot;focused&quot; flag is set and then</span></div><div class="line">    <span class="comment">// the window is repainted.</span></div><div class="line">    intlib-&gt;SubscribeGazeFocusEvents([](IL::GazeFocusEvent evt, <span class="keywordtype">void</span>* context)</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> gazeFocusEventContext{static_cast&lt;GazeFocusEventContext*&gt;(context)};</div><div class="line">        gazeFocusEventContext-&gt;focused = evt.hasFocus;</div><div class="line">        gazeFocusEventContext-&gt;window.Repaint();</div><div class="line">    }, &amp;gazeFocusEventContext);</div><div class="line"></div><div class="line">    <span class="comment">// When the window repaints itself, it invokes this event to ask for the color to use.</span></div><div class="line">    window.OnPaint = [&amp;] (<span class="keywordtype">int</span>&amp; sysColorIndex)</div><div class="line">    {</div><div class="line">        sysColorIndex = gazeFocusEventContext.focused ? COLOR_HIGHLIGHT : COLOR_WINDOW;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// Now that all events and subscriptions are set up, the physical window can be created.</span></div><div class="line">    window.Create();</div><div class="line">    </div><div class="line">    <span class="comment">// Handle window events and update interaction library to trigger all callbacks</span></div><div class="line">    <span class="keywordflow">while</span> (ProcessMessages())</div><div class="line">    {</div><div class="line">        intlib-&gt;Update();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
</body>
</html>
