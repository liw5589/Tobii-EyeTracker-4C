<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tobii Interaction Library SDK: C++: Tobii Interaction Library SDK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
<link href="code.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.15 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Tobii Interaction Library SDK </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>[<a href="../../sdk/html/index.html">Back to the SDK start page</a>]</p>
<h1><a class="anchor" id="autotoc_md1"></a>
C++ Sample Walkthrough</h1>
<p>This section describes the typical workflow when using the C++ API of the Interaction Library SDK.</p>
<p>Let's assume the eye tracker is on the main screen and that the resolution is 2560x1440 pixels.</p>
<p>We want to tell the Interaction Library about 4 regions on screen (A, B, C and D in the picture below) for which we want to know when the user looks at them (or not). As our gaze enters and leaves them, the Interaction Library will emit "got focus" and "lost focus" events that we can react to in our client application.</p>
<p>Such a screen region is called an <em><a class="el" href="class_i_l_1_1_interaction_lib.html#interactors">interactor</a></em> in the Interaction Library API.</p>
<div class="fragment"><div class="line">A screen with 4 &quot;corner&quot; interactors A, B, C and D:</div><div class="line"></div><div class="line">                   2560</div><div class="line">  +-------+-------------------+-------+</div><div class="line">  |       |                   |       |</div><div class="line">  |   A   | 500           500 |   B   |</div><div class="line">  |       |                   |       |</div><div class="line">  +-------+                   +-------+</div><div class="line">  |  500                         500  |</div><div class="line">  |                                   | 1440</div><div class="line">  |  500                         500  |</div><div class="line">  +-------+                   +-------+</div><div class="line">  |       |                   |       |</div><div class="line">  |   C   | 500          500  |   D   |</div><div class="line">  |       |                   |       |</div><div class="line">  +-------+------------------ +-------+</div></div><!-- fragment --><p>In the following, error checking is omitted for readability (most API functions return an <a class="el" href="namespace_i_l.html#a28287671eaf7406afd604bd055ba4066">IL::Result</a> value, where <a class="el" href="namespace_i_l.html#a28287671eaf7406afd604bd055ba4066aa60852f204ed8028c1c58808b746d115">IL::Result::Ok</a> is the generic "success" value).</p>
<p>Make sure that the compiler and linker can find the Interaction Library C++ API headers and static or dynamic libraries, then include the main library header file:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;interaction_lib/InteractionLib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;interaction_lib/misc/InteractionLibPtr.h&gt;</span></div></div><!-- fragment --><p> Create an instance of the Interaction Library implementation with <a class="el" href="group__initsetup.html#ga4f891417c45f2116e3a8c9622358952f">CreateInteractionLib() </a>. Please note that the <a class="el" href="class_i_l_1_1_interaction_lib.html" title="Interface to the features exposed by the Interaction Library.">IL::InteractionLib</a> pointer returned <b>must</b> be deleted with <a class="el" href="group__initsetup.html#ga08f270409b0233fc1165fe3cd0ee7342">DestroyInteractionLib() </a>. The Interaction Library SDK provides <a class="el" href="namespace_i_l.html#a9f6de98cf831a4b915dbabe93777dfd2">IL::UniqueInteractionLibPtr</a> for convenience, which is just a typedef for a <code>std::unique_ptr&lt;&gt;</code> with a custom deleter that uses the aforementioned <a class="el" href="group__initsetup.html#ga08f270409b0233fc1165fe3cd0ee7342">DestroyInteractionLib() </a> (but you are of course under no obligation to use it).</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// create the interaction library</span></div><div class="line">    <a class="code" href="namespace_i_l.html#a9f6de98cf831a4b915dbabe93777dfd2">IL::UniqueInteractionLibPtr</a> intlib(<a class="code" href="group__initsetup.html#ga4f891417c45f2116e3a8c9622358952f">IL::CreateInteractionLib</a>(<a class="code" href="namespace_i_l.html#a9ad82351abcbbbfdbaa5c1eaf076c59ca24b9b8c0634a40138e76b2fb86894698">IL::FieldOfUse::Interactive</a>));</div></div><!-- fragment --><p> Tell the Interaction Library our screen size with <a class="el" href="class_i_l_1_1_interaction_lib.html#abc95ec3d1e5418348f836cca6d964226">CoordinateTransformAddOrUpdateDisplayArea() </a> and which origo our interactor coordinates are relative to with <a class="el" href="class_i_l_1_1_interaction_lib.html#a7453c2d910598f3a2003d7b9d9acdada">CoordinateTransformSetOriginOffset() </a>. The latter is most useful if you want to use interactors with window local coordinates; simply update the offset as the window moves rather than all interactors.</p>
<div class="fragment"><div class="line">    constexpr <span class="keywordtype">float</span> width  = 2560.0f;</div><div class="line">    constexpr <span class="keywordtype">float</span> height = 1440.0f;</div><div class="line">    constexpr <span class="keywordtype">float</span> offset = 0.0f;</div><div class="line"></div><div class="line">    intlib-&gt;CoordinateTransformAddOrUpdateDisplayArea(width, height);</div><div class="line">    intlib-&gt;CoordinateTransformSetOriginOffset(offset, offset);</div></div><!-- fragment --><p> Tell the Interaction Library where our interactors are located with <a class="el" href="class_i_l_1_1_interaction_lib.html#ae837b28d31609f5689160e09d786e764">AddOrUpdateInteractor() </a>. This must be done between matching calls to <a class="el" href="class_i_l_1_1_interaction_lib.html#a08ed6217c63cbbf222ae061f14a6cf85">BeginInteractorUpdates() </a> and <a class="el" href="class_i_l_1_1_interaction_lib.html#a83dfd4c29298c45e693a5aaa9c451d35">CommitInteractorUpdates() </a>, as changes will be handled in safe and optimized batches. An interactor is identified by a unique client supplied ID. Also, interactors can overlap each other and be stacked in z-order but we leave them all at 0 in this sample.</p>
<div class="fragment"><div class="line">    constexpr <a class="code" href="namespace_i_l.html#ac93c351dc8ba1191a6c85750472c29e9">IL::InteractorId</a> idA = 0;</div><div class="line">    constexpr <a class="code" href="namespace_i_l.html#ac93c351dc8ba1191a6c85750472c29e9">IL::InteractorId</a> idB = 1;</div><div class="line">    constexpr <a class="code" href="namespace_i_l.html#ac93c351dc8ba1191a6c85750472c29e9">IL::InteractorId</a> idC = 2;</div><div class="line">    constexpr <a class="code" href="namespace_i_l.html#ac93c351dc8ba1191a6c85750472c29e9">IL::InteractorId</a> idD = 3;</div><div class="line"></div><div class="line">    constexpr <span class="keywordtype">float</span> size = 500.0f;</div><div class="line">    constexpr <a class="code" href="struct_i_l___rectangle.html">IL::Rectangle</a> rectA = {            0,             0, size, size };</div><div class="line">    constexpr <a class="code" href="struct_i_l___rectangle.html">IL::Rectangle</a> rectB = { width - size,             0, size, size };</div><div class="line">    constexpr <a class="code" href="struct_i_l___rectangle.html">IL::Rectangle</a> rectC = {            0, height - size, size, size };</div><div class="line">    constexpr <a class="code" href="struct_i_l___rectangle.html">IL::Rectangle</a> rectD = { width - size, height - size, size, size };</div><div class="line"></div><div class="line">    constexpr <span class="keywordtype">float</span> z = 0.0f;</div><div class="line"></div><div class="line"></div><div class="line">    intlib-&gt;BeginInteractorUpdates();</div><div class="line"></div><div class="line">    intlib-&gt;AddOrUpdateInteractor(idA, rectA, z);</div><div class="line">    intlib-&gt;AddOrUpdateInteractor(idB, rectB, z);</div><div class="line">    intlib-&gt;AddOrUpdateInteractor(idC, rectC, z);</div><div class="line">    intlib-&gt;AddOrUpdateInteractor(idD, rectD, z);</div><div class="line"></div><div class="line">    intlib-&gt;CommitInteractorUpdates();</div></div><!-- fragment --><p> To get a way of breaking out of the "update loop" (described further down), we track if the same interactor gets focus 3 times in a row, and if so exit the program. We use a simple struct for that tracking.</p>
<div class="fragment"><div class="line">    <span class="keyword">struct </span>Focus</div><div class="line">    {</div><div class="line">        <a class="code" href="namespace_i_l.html#ac93c351dc8ba1191a6c85750472c29e9">IL::InteractorId</a> <span class="keywordtype">id</span>    = <a class="code" href="namespace_i_l.html#a574afd2a89d338692465799abb7a89b3">IL::EmptyInteractorId</a>();</div><div class="line">        <span class="keywordtype">size_t</span>           count = 0;</div><div class="line">    };</div><div class="line">    Focus focus;</div></div><!-- fragment --><p> Tell the Interaction Library we want to get interactor focus events with <a class="el" href="class_i_l_1_1_interaction_lib.html#af007c9cd33bbf0b278016852775816fb">SubscribeGazeFocusEvents() </a>. When our gaze enters and leaves the interactors, the lambda callback function provided will be called by the Interaction Library and the event information is printed to standard output.</p>
<div class="fragment"><div class="line">    intlib-&gt;SubscribeGazeFocusEvents([](<a class="code" href="struct_i_l___gaze_focus_event.html">IL::GazeFocusEvent</a> evt, <span class="keywordtype">void</span>* context)</div><div class="line">    {</div><div class="line">        Focus&amp; focus = *static_cast&lt;Focus*&gt;(context);</div><div class="line">        std::cout</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Interactor: &quot;</span> &lt;&lt; evt.<a class="code" href="struct_i_l___gaze_focus_event.html#ad00eeb8cfdcf4eaffd7c538e0dfec945">id</a></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;, focused: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; evt.<a class="code" href="struct_i_l___gaze_focus_event.html#a835648d04e554fd4433cd2a902b7423a">hasFocus</a></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;, timestamp: &quot;</span> &lt;&lt; evt.<a class="code" href="struct_i_l___gaze_focus_event.html#a018da25e743cdf128f8dd633e6ca2e00">timestamp_us</a> &lt;&lt; <span class="stringliteral">&quot; us&quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (evt.<a class="code" href="struct_i_l___gaze_focus_event.html#a835648d04e554fd4433cd2a902b7423a">hasFocus</a>)</div><div class="line">        {</div><div class="line">            focus.count = focus.id == evt.<a class="code" href="struct_i_l___gaze_focus_event.html#ad00eeb8cfdcf4eaffd7c538e0dfec945">id</a> ? focus.count + 1 : 1;</div><div class="line">            focus.id = evt.<a class="code" href="struct_i_l___gaze_focus_event.html#ad00eeb8cfdcf4eaffd7c538e0dfec945">id</a>;</div><div class="line">        }</div><div class="line">    }, &amp;focus);</div></div><!-- fragment --><p> Tell the Interaction Library to continuously evaluate eye tracker gaze data and call any client event subscribers with <a class="el" href="class_i_l_1_1_interaction_lib.html#a793023fac72fa747e05d7bf4a600aa69">WaitAndUpdate() </a>. In the event that no device is connected, WaitAndUpdate() will attempt to find and connect to a tracker once per second. Since WaitAndUpdate() will often block the calling thread, you would normally put this loop on its own thread. WaitAndUpdate() is a convenience method that handles device connections, waiting for data and updating the Interaction Library to perform all calculation and trigger relevant callbacks all in one method. If you need granular control over updates and/or non-blocking calls use a suitable combination of the various other control methods available in the API.</p>
<div class="fragment"><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Starting interaction library update loop.\n&quot;</span>;</div><div class="line"></div><div class="line">    constexpr <span class="keywordtype">size_t</span> max_focus_count = 3;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (focus.count &lt; max_focus_count)</div><div class="line">    {</div><div class="line">        intlib-&gt;WaitAndUpdate();</div><div class="line">    }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Interactor &quot;</span> &lt;&lt; focus.id &lt;&lt; <span class="stringliteral">&quot; got focused &quot;</span> &lt;&lt; focus.count &lt;&lt; <span class="stringliteral">&quot; times\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p> Finally:</p>
<ul>
<li>Compile and run the sample code. Its entirety can be found here: <a class="el" href="sample_cpp.html">C++ Sample Complete Code</a></li>
<li>Observe how gaze focus "enter" and "leave" event information gets printed to standard output.</li>
<li>Focus the same interactor 3 times in a row to exit the sample program. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</body>
</html>
